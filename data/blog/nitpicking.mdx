---
title: "The Philosophy of Nitpicking"
date: "2025-03-24"
lastmod: "2025-03-24"
tags:
    [
        "nitpicking",
        "eslint",
        "prettier",
        "editorconfig",
        "knip",
        "programming",
        "typescript"
    ]
draft: true
summary: "Why you should nitpick, and how you can use linting to do it without making your colleagues hate you"
authors: ["default"]
---

- [Why we should all be nitpickers](#why-we-should-all-be-nitpickers)
- [How to automate it](#how-to-automate-it)
- [Prettier](#prettier)
- [EditorConfig](#editorconfig)
- [tsconfig](#tsconfig)
- [Knip](#knip)
- [ESLint](#eslint)
- [How do we enforce all of this?](#how-do-we-enforce-all-of-this)
    - [Recommended IDE extensions](#recommended-ide-extensions)
        - [.vscode/extensions.json](#vscodeextensionsjson)
        - [.vscode/settings.json](#vscodesettingsjson)
    - [Pre-commit hooks](#pre-commit-hooks)
    - [Build pipeline](#build-pipeline)
        - [GitHub workflow](#github-workflow)
        - [GitHub repository settings](#github-repository-settings)

If there was a Nitpickers Anonymous support group, I'd be member number one.

Poorly named variables, incorrect camel-case capitalisation, typos, line breaks not in the right spot, exports that are never imported, ternary statements nested within ternary statements, functions with too many arguments - these are the things that keep me up at night.

In case you're thinking "that doesn't seem so bad, those things would bother me too", then I can assure you that for me it goes to a much deeper pathological level.

If I see someone start a single line comment without a space after the slashes `//like this` it bothers me. What sort of psychopath doesn't stylise their comments `// like this`?

God forbid I stumble across someone committing a string literal that uses a curly quote like this `â€™` (Unicode U+2019) instead of a perfectly good straight quote `'`.

You may imagine that endlessly requesting changes for such tedious trivialities is not helping me win any friends among my colleagues, and you would be right. But I hope to make the case for two points in this article:

1. That nitpicking has value
2. That with the use of some handy tools, we can automate away our nitpicking, both winning back the love of our colleagues, and making their lives easier

## Why we should all be nitpickers

Granted, making the case in defense of spending our valuable time and energy worrying about the unimportant stylistic aspects of code is hard to do.

C. Northcote Parkinson, in 1957, spoke of a concept which has since become known as the [Law of Triviality](https://en.wikipedia.org/wiki/Law_of_triviality), which proposes that the amount of time we tend to spend discussing a problem is inversely proportional to the importance of the problem.

He

1. Less bugs
2. Less wasted time debating trivialities
3. Consistent code and user experience
4. Easier for new starters

## How to automate it

Four tools in order of importance:

1. ESLint
2. Prettier
3. Knip
4. Editorconfig
5. tsconfig (bonus point for typescript project, and while not a tool, there is some specific configuration worth mentioning)
6. VSCode
7. CI Pipeline
8. Precommit hooks (prettier lint-staged?)

## Prettier

It might be reasonable to ask, that in a world where ESLint has become so powerful, is there even a need for formatting tools like Prettier or dprint anymore? Why not just let ESLint do everything? Unfortunately for those of us hoping to slim down our number of dev-dependencies by one, ESLint is very much not intended to be used for formatting, to the point where the team has [deprecated all formatting rules and recommends using a dedicated code-formatter instead](https://eslint.org/blog/2023/10/deprecating-formatting-rules).

Prettier is simple, smart and popular, and is worth using in any JavaScript/TypeScript project.

While Prettier can be used with its out-of-the-box defaults and no config file, if you follow my recommendation and also use EditorConfig, it is important that you don't configure Prettier in a way that conflicts with it. Prettier is smart here, and for tabs, tab width and end-of-line will honour what is defined in an `.editorconfig` file, so you're best just leaving these values out.

Based on your preference, there are many further options which you can read about [here](https://prettier.io/docs/options). These can be added to a `.prettierrc` file. It is worth familiarising yourself with these options before working on your customer ESLint rules. Your rule of thumb should be "if Prettier can do it, then don't use ESLint". Some common examples are enforcing standards about usage of single vs double quotes or ending lines with semicolons. These are jobs for prettier.

## EditorConfig

The [EditorConfig](https://editorconfig.org/) project simply defines a file format that specifies coding styles that your IDE of choice will adhere to, [either natively](https://editorconfig.org/#pre-installed) or [with the addition of a plugin](https://editorconfig.org/#download) depending on your editor of choice.

Although formatters like the aforementioned Prettier have very wide support for different file types, there will inevitably crop up an example in your codebase at some point which is not supported (a couple of common examples are files like `Makefile` and `.gitignore`), so having an editor-level formatter which supports all text-based files will help maintain consistency for these edge cases.

Here is the `.editorconfig` setup I use, which you can tweak based on taste.

```shell
# Top-most EditorConfig file
root = true

[*]
end_of_line = lf # Unix-style newlines
insert_final_newline = true # Newline ending every file
trim_trailing_whitespace = true # Trim whitespace preceding newlines
charset = utf-8 # Enforce consistent character set
indent_style = tab # Matter of taste
index_size = 4 # Number of columns used for indentation
```

When an inevitable exception comes up where you have a particular file type that needs to be formatted differently, you can simply override your `[*]` config for that type. For example:

```shell
# Continuing on from example above

[*.{yaml,yml}]
index_size = 2
```

Unlike all the other tools mentioned in this article, EditorConfig, unfortunately, is not something we are able to run in our CI pipelines to fail a build if an offense occurs.

## tsconfig

This doesn't fall very nicely into the category of linting and formatting, but there are a few type-checking configuration options for the TypeScript compiler that are simply too powerful not to mention, both from a code cleanliness and reduced-risk-of-bugs perspective.

The easiest way to get your configuration into ship-shape is to go and add everything marked as "Recommended" in [TypeScript's documentation](https://www.typescriptlang.org/tsconfig/). There are a few, however, worth drawing extra attention to.

The absolute number one thing you should turn on is `strict: true`, which enables all of

- `alwaysStrict`
- `strictNullChecks`
- `strictBindCallApply`
- `strictBuiltinIteratorReturn`
- `strictFunctionTypes`
- `strictPropertyInitialization`
- `noImplicitAny`
- `noImplicitThis`
- `useUnknownInCatchVariables`

Special emphasis goes to `strictNullChecks`. If you don't like seeing `Uncaught TypeError: Cannot read properties of undefined`, this is an option for you.

A few more rules that are valuable for cleaner code are:

- `allowUnreachableCode` (as `false`)
- `noUnusedLocals`
- `noUnusedParameters`

## Knip

This might be the lesser known tool out of all that I am going through, however I can't overemphasise how much I love it. While ESLint is great at helping you identify and resolve problematic patterns within files, it is not so useful for catching issues that require looking across multiple files, or even dependencies. This is where Knip comes in.

The [Knip documentation](https://knip.dev/explanations/why-use-knip) has a very good overview of why to use this tool, but for me the two most important things are:

1. Identification of dead code (very importantly, this includes exported code which is never imported anywhere)
2. Identification of unused dependencies

Knip will run without any config file, however depending on the structure and the sort of dependencies you have in your project, it may come up with some false flags, or fail to identify some legitimate issues, in which case we need to tinker with it a little bit.

## ESLint

And now we're on to the big-daddy of all the tools I've mentioned here.

ESLint is possibly the most powerful static analysis tool we have at our disposal for JavaScript and TypeScript code thanks a lot to its massive suite of native and third-party rules and plugins.

Due to the extent of these rules, it can also be a bit overwhelming to know where to start and know what rules you should be turning on. I'll aim to demystify it a little and demonstrate that we can get 99% of the benefit of ESLint with just a handful of plugins, and no complex configuration.

Use with prettier recommends eslint-config-prettier (not plugin) https://prettier.io/docs/integrating-with-linters

// /\*_
// _ Plugins to add
// _ - import (no restricted paths) (eslint-plugin-import??)
// _ - no-smart-quotes
// _ - eslint-config-prettier (prettier recommends this vs plugin-prettier)
// _ - spellcheck
// _ - todo-plz
// _ - check-file (enforce file names)
// _
// _ ESlint next includes recommended:
// _ - eslint-plugin-react
// _ - eslint-plugin-react-hooks
// _ - eslint-plugin-next
// _ - typescript-eslint/recommended
// _
// _ Plugin react (not many on in recommended):
// _ - forbid-component-props
// _
// _ Variable naming
// _ - no-restricted-syntax without type info
// _ - naming-convention with type information
// _/

yarn add --dev jiti // for ts eslint config?

## How do we enforce all of this?

Having handy-dandy linting and formatting rules is all well and good, but if we are relying on simply trusting our team manually run some commands locally before committing, we're in for sore disappointment. Sometimes mistakes happen. Sometimes new starters join who don't know what scripts to run before committing. Despite our best efforts to set up all the tooling I've outlined above, we wouldn't reach the end of the day before unformatted unlinted code makes it into `master`.

Thankfully, there are a few strategies we can use to automate execution of our checks and tooling for developers to make their lives easier, and if it is necessitated, preventing their code reaching `master` if they've somehow avoided them.

My recommendation is a combination of all three of the following, which I will break down one at a time:

1. Recommended IDE extensions and settings that result in autoformatting/linting on save of files
2. Pre-commit hooks that run (and where possible autofix) issues prior to committing
3. Build pipeline checks to fail our build and prevent merging our pull request to master if the above two fail

### Recommended IDE extensions

This tip is unfortunately Visual Studio Code specific. While there is no guarantee everyone working on your project uses the same IDE, in 2025 VS Code continues to be ubiquitous in the industry so is worth mentioning.
Making a `.vscode` directory in our project enables us to add a couple of useful files that encourage consistency across developers.

#### .vscode/extensions.json

Here we can add a list of recommended extensions for which any developer opening your project will be prompted to install with a dialog that looks like this:

![VS Code Recommended Extension](/static/images/nitpicking/vscode_recommended_extension.webp)

Essential extensions to recommend, if you've followed this article up until now, are [EditorConfig for VS Code](https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig), [Prettier - Code formatter](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode) and [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint).

```json
{
	"recommendations": [
		"dbaeumer.vscode-eslint",
		"esbenp.prettier-vscode",
		"editorconfig.editorconfig"
	]
}
```

_If you want to add further extensions to `recommendations`, you can find the correct name to pass in under a value "Unique Identifier" found on the extension's marketplace page._

#### .vscode/settings.json

VS Code has two types of settings:

1. User Settings - This is your local VS Code configuration that will apply across any project that you open.
2. Workspace Settings - This applies just to the current project you have open, and is committed to source control.

We have no control over what our colleagues use for number 1, so number 2, workspace settings, is the important one.
There are many powerful configuration options we have at our disposal here which are worth researching, but focusing on the scope of formatting and linting, to enable automatic running of Prettier and ESLint on save, we can add the follow to our workspace `settings.json`:

```json
{
	"editor.formatOnSave": true,
	"editor.defaultFormatter": "esbenp.prettier-vscode",
	"editor.codeActionsOnSave": {
		"source.fixAll.eslint": "explicit"
	}
}
```

### Pre-commit hooks

If the developer managed to get save files without running our formatting and linting tools on them, perhaps because they weren't using VS Code or didn't install the recommended extensions, then the next safeguard in our arsenal is pre-commit hooks. These are simply scripts that automatically run locally on our machine before we commit.

In our case, we will use a very common combination of [husky](https://typicode.github.io/husky/) to implement our pre-commit hook and [lint-staged](https://github.com/lint-staged/lint-staged) to run linters on our staged files.

To get started, we will add the dependencies and initialise husky:

```shell
yarn add husky --dev
yarn add lint-staged --dev
yarn husky init
```

Now we want to define what `lint-staged` is actually going to run by adding a new property `lint-staged` to our `package.json`. _Ideally_, it would perform both linting and formatting, which would look something like this:

```json
"lint-staged": {
	"*.+(js|jsx|ts|tsx|json|css|md|mdx)": [
		"prettier --write",
		"eslint --fix"
	]
}
```

We then want to update `.husky/pre-commit` to actually run `lint-staged`. This is also a time where we could run `knip`:

```shell
yarn lint-staged
yarn knip
```

Above I said _"ideally"_, as there comes a time when we need to be pragmatic about what we run as a pre-commit hook. A good rule of thumb is that your checks should take no longer than about 10 seconds. Any longer is really going to start annoying developers working on your project. `prettier` is blazing fast so is always a no brainer to run, but `knip` and `eslint` may need to be culled on larger projects.

### Build pipeline

Even with recommending useful browser extensions and adding pre-commit hooks, you can be certain that some developer at some stage will manage to still bypass our linting. Maybe a junior on our team had `eslint` fail in a pre-commit hook script but the error message was confusing. They google it and find the solution is to just retry the commit with `--no-verify`. If that sneaks past code review, now we've got unlinted code into `master`.

This is where our final and 100% foolproof safeguard comes in - running all our checks in a build pipeline and having the result of that build be a static check which is required to pass before merging our code into master.

How you achieve this is going to be different based on what CI provider and git hosting platform you use, but my example will be for those using GitHub and GitHub Actions.

#### GitHub workflow

This one is simple. You just want to run all your static checks as build steps. Here is a sample workflow file you can use. I have saved this in `.github/workflows/static-checks.yml`:

```yaml
name: Code Validation

on:
    pull_request:
    workflow_dispatch:

jobs:
    build:
        name: Static Checks
        runs-on: ubuntu-latest
        steps:
            - uses: actions/checkout@v4
            - name: Install modules
              run: yarn
            - name: Lint
              run: yarn lint-nofix
            - name: Prettier
              run: yarn prettier-nofix
            - name: Knip
              run: yarn knip
```

#### GitHub repository settings

Next we want to apply some settings to our repository that ensure that only code that passes our `Static Checks` build can find its way into `master`.

1. Go to repository settings and create a new branch ruleset
   ![Create a branch ruleset](/static/images/nitpicking/github_ruleset_step_1.webp)
2. Name your ruleset (`main` or `master` should do the trick) and set the target branch to the default branch
   ![Set the target branch](/static/images/nitpicking/github_ruleset_step_2.webp)
3. Under "Branch rules" check "Require a pull request before merging" and "Require status checks to pass" ("Restrict deletions" and "Block force pushes" are selected by default)
   ![Configure branch rules](/static/images/nitpicking/github_ruleset_step_3.webp)
4. Expand "Show additional settings" under "Require status checks to pass" and select the "Static Checks" GitHub Action.
   ![Require static checks](/static/images/nitpicking/github_ruleset_step_4.webp)
5. Hit "Save Changes"

Now that we have made it so that no one can commit directly to `master` without a pull request and our new status check is required to pass to merge a pull request, the next time someone raises a pull request that doesn't pass our linting and formatting, they will see a UI that looks like this:

![Pull request with unsuccessful checks](/static/images/nitpicking/github_checks_not_successful_ui.webp)
