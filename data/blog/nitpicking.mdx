---
title: "Linting and Formatting TypeScript in 2025"
date: "2025-03-24"
lastmod: "2025-03-24"
tags:
    [
        "nitpicking",
        "eslint",
        "prettier",
        "editorconfig",
        "knip",
        "programming",
        "typescript"
    ]
draft: true
summary: "Why you should nitpick, and how you can use linting to do it without making your colleagues hate you"
authors: ["default"]
---

- [Automating our nitpicking](#automating-our-nitpicking)
- [EditorConfig](#editorconfig)
- [Prettier](#prettier)
- [ESLint](#eslint)
    - [Setup](#setup)
    - [Recommended configurations](#recommended-configurations)
        - [typescript-eslint](#typescript-eslint)
        - [@stylistic/eslint-plugin](#stylisticeslint-plugin)
        - [eslint-config-prettier](#eslint-config-prettier)
        - [eslint-plugin-react, eslint-plugin-react-hooks and eslint-plugin-react-refresh](#eslint-plugin-react-eslint-plugin-react-hooks-and-eslint-plugin-react-refresh)
        - [eslint-plugin-spellcheck and eslint-plugin-react-prefer-function-component](#eslint-plugin-spellcheck-and-eslint-plugin-react-prefer-function-component)
    - [Customising rules beyond recommended configurations](#customising-rules-beyond-recommended-configurations)
- [tsconfig](#tsconfig)
    - [Knip](#knip)
    - [How do we enforce all of this?](#how-do-we-enforce-all-of-this)
        - [Recommended IDE extensions](#recommended-ide-extensions)
            - [.vscode/extensions.json](#vscodeextensionsjson)
            - [.vscode/settings.json](#vscodesettingsjson)
        - [Pre-commit hooks](#pre-commit-hooks)
        - [Build pipeline](#build-pipeline)
            - [GitHub workflow](#github-workflow)
            - [GitHub repository settings](#github-repository-settings)
    - [Why we should all be nitpickers](#why-we-should-all-be-nitpickers)

If there was a Nitpickers Anonymous support group, I'd be member number one.

Poorly named variables, typos, line breaks missing (or in places they shouldn't be), exports that are never imported, ternary statements nested within ternary statements, functions with too many arguments - these are the things that keep me up at night.

In case you're thinking "that doesn't seem so bad, those things would bother me too", then I can assure you that for me it goes to a much more pathological level.

If I see someone start a single line comment without a space after the slashes `//like this` it bothers me. What sort of psychopath doesn't stylise their comments `// like this`?

God forbid I stumble across someone committing a string literal that uses a curly quote like this `â€™` (Unicode U+2019) instead of a perfectly good straight quote `'`.

You may imagine that endlessly requesting changes for such tedious trivialities on the pull requests of my colleagues would not be winning me any friends, and you would be right. Thankfully though, modern tools are effective enough that most of the time I don't have to.

# Automating our nitpicking

In this article I will outline what linting and formatting tools are must-haves in your TypeScript projects _(the vast majority I cover is also applicable to JavaScript)_, covering:

1. EditorConfig
2. Prettier
3. ESLint
4. Knip
5. tsconfig (not exactly a tool, however specific configuration that warrants mentioning)

And finally, I will share how to make it as easy as possible for your team to use these tools and how to enforce their use, through:

1. Visual Studio Code recommended extensions and settings
2. Pre-commit hooks
3. GitHub workflows and repository settings

_If looking at the code rather than reading is your thing, I have setup all the tools and configuration I describe in a [demo repository](https://github.com/fnannestad/formatting-linting-demo)._

# EditorConfig

The [EditorConfig](https://editorconfig.org/) project defines a file format that specifies coding styles that your IDE of choice will adhere to, [either natively](https://editorconfig.org/#pre-installed) or [with the addition of a plugin](https://editorconfig.org/#download) depending on your editor of choice.

Although formatters like the Prettier have very wide support for different file types, there will inevitably crop up an example in your codebase at some point which is not supported (a couple of common examples are files like `Makefile` and `.gitignore`), so having an editor-level formatter which supports all text-based files will help maintain consistency for these edge cases.

Configure EditorConfig by creating a file `.editorconfig` at the top level of your project. Here is the setup I use, which you can tweak based on taste:

```shell
# Top-most EditorConfig file
root = true

[*]
end_of_line = lf # Unix-style newlines
insert_final_newline = true # Newline ending every file
trim_trailing_whitespace = true # Trim whitespace preceding newlines
charset = utf-8 # Enforce consistent character set
indent_style = tab # Matter of taste
tab_width = 4 # Number of columns used to represent a tab character
```

When an inevitable exception comes up where you have a particular file type that needs to be formatted differently, you can simply override your `[*]` config for that type. For example:

```shell
# In the same file as above, below the definition for [*]
[*.{yaml,yml}]
tab_width = 2
```

It is also worth nothing that Prettier automatically adopts the values specified in an `.editorconfig` file for `tab_width`, `indent_style` and `end_of_line` unless overridden.

# Prettier

It might be reasonable to ask, _"Why in a world where ESLint has become so powerful, is there even a need for formatting tools like Prettier anymore?_

Unfortunately for those of us hoping to slim down our number of dev-dependencies by one, ESLint is very much not intended to be used for formatting, to the point where the team has [deprecated all formatting rules and recommends using a dedicated code-formatter instead](https://eslint.org/blog/2023/10/deprecating-formatting-rules).

Prettier is simple and fast, and is worth using in any JavaScript/TypeScript project. Install it with

```shell
yarn add prettier --dev
```

Prettier can be used with its out-of-the-box defaults and, as mentioned above, will inherit settings from `.editorconfig`. It is important not to override these to different values in your Prettier config file to avoid conflicts. If you want to customise it further, you can create a `.prettierrc` file at the top level of your project. Here is an example configuration I use

```json
{
	"semi": false,
	"trailingComma": "none",
	"quoteProps": "consistent",
	"printWidth": 80
}
```

Based on your preference, there are many further options which you can read about [here](https://prettier.io/docs/options). It is worth familiarising yourself with these options before working on your ESLint config. Your rule of thumb should be "if Prettier can do it, then don't use ESLint". Some common examples are enforcing standards about usage of single vs double quotes or ending lines with semicolons. These are jobs best left for Prettier.

If you want to avoid running prettier against specific files or paths, you can add them to a `.prettierignore` file.

# ESLint

And now we're on to the big-daddy. ESLint is the most powerful static analysis tool we have at our disposal for JavaScript and TypeScript code, thanks a lot to its massive suite of native and third-party rules and plugins.

Due to the extent of these rules, it can also be a bit overwhelming to know where to start and know what rules you should be turning on. I'll aim to demystify it a little and demonstrate that we can get 99% of the benefit of ESLint with just a handful of plugins, and no complex configuration.

Install ESLint with this command:

```shell
yarn create @eslint/config
```

This will also create the ESLint config file `eslint.config.mjs`.

_N.B. In 2022 ESLint [introduced a new configuration format](https://eslint.org/blog/2022/08/new-config-system-part-2/) called "Flat Config". They say it is intended to be "much simpler than the original config system". I'm not completely sure I agree, however it is a little more flexible and not so bad once we've wrapped our head around it._

Unlike the other tools I mention in this article, ESLint is a little more complex and not practical to explain in full here. If you're completely new to it, I recommend checking our [their page on core concepts](https://eslint.org/docs/latest/use/core-concepts/), then returning to this article.

I'll also not get too involved in the config file syntax, however I have put together an entire example with everything I will cover here which you can find in the [aforementioned demo repository](https://github.com/fnannestad/formatting-linting-demo/blob/main/eslint.config.ts).

## Setup

Unlike the other tools, I won't go through step by step here on how to set everything up, as this would fill up an entire blog post of its own, however if you are looking for a code example, please checkout the config I have put together in the [aforementioned demo repository](https://github.com/fnannestad/formatting-linting-demo/blob/main/eslint.config.ts). _Please note that here I have used TypeScript for my ESLint config. If you wish to do the same, you need to also add `jiti` to your dev-dependencies._

To install all the plugins and configurations I will be talking through, you can run this command:

```shell
yarn add --dev typescript-eslint \
	@stylistic/eslint-plugin \
	eslint-config-prettier \
	eslint-plugin-react \
	eslint-plugin-react-hooks \
	eslint-plugin-react-refresh \
	eslint-plugin-spellcheck \
	eslint-plugin-react-prefer-function-component
```

## Recommended configurations

Both core ESLint and most plugins you will use have a large number of rules and it can be quite overwhelming to decide which are enabled. Thankfully, most of the time they also come with a "recommended" set of rules. These are rules that desirable for the vast majority of projects, and can be turned on with a single line of configuration.

If you're already using a framework that has an ESLint configuration generated by default, it is possible you are using some of these without realising. For example, if you create a NextJS project with ESLint, it will automatically add [eslint-config-next](https://nextjs.org/docs/app/api-reference/config/eslint#reference), which includes `eslint-plugin-react` and `eslint-plugin-react-hooks` by default.

So please do your research first to avoid duplication. That being said though, there are a few I recommend (pun not intended).

### typescript-eslint

`typescript-eslint` is the primary library we will be using to lint our TypeScript code and I recommend multiple configurations

1. [eslint-recommended](https://typescript-eslint.io/users/configs/#eslint-recommended) - This is the full set of regular core ESLint recommended rules, with just a few disabled that are handled automatically by TypeScript. These are rules that basically always identify bad practices or bugs.
2. [strict-type-checked](https://typescript-eslint.io/users/configs/#strict-type-checked) - Includes all `recommended` and `strict` rules from TypeScript ESLint, along with additional ones requiring TypeScript type checking information.
3. [stylistic-type-checked](https://typescript-eslint.io/users/configs/#stylistic-type-checked) - Applies rules considered best practise for TypeScript projects that don't impact logic. Generally just enforcing cleaner code.

The last two rules have a big asterisk against them - enabling rules that require type information heavily impacts ESLint performance to the point where it may be impractical to use on large codebases. I have seen them changing execution time from 30 seconds up to almost 30 minutes.

If your codebase falls into this category, `strict-type-checked` can be swapped out for `strict`, and `stylistic-type-checked` can be swapped out for `stylistic`.

### @stylistic/eslint-plugin

I mentioned in the section on Prettier that we shouldn't use ESLint for formatting, however I somewhat lied. [ESLint Stylistic](https://eslint.style/) has replaced the now-deprecated formatting ESLint rules and I strongly recommend using its recommended configuration. Prettier is great for our fundamental formatting, however doesn't go remotely as deep as ESLint can. Its [many rules](https://eslint.style/packages/default#rules) will make your code sexy. Add the plugin and apply the recommended config.

### eslint-config-prettier

[This one](https://github.com/prettier/eslint-config-prettier) is simple. It turns off all ESLint rules that conflict with Prettier.

_N.B. You may find references to something called `eslint-plugin-prettier`. This is [not recommended to be used by Prettier](https://prettier.io/docs/integrating-with-linters#notes)_

### eslint-plugin-react, eslint-plugin-react-hooks and eslint-plugin-react-refresh

If you're not working with React, swap these out for equivalents that doubtlessly exist for your framework of choice, however these are the most useful plugins if you are. The first two are self-explanatory. `eslint-plugin-react-refresh` will report any case where a component is structured in a way that will break fast refreshing. Use the recommended config for each of these.

### eslint-plugin-spellcheck and eslint-plugin-react-prefer-function-component

These are some very specific oddballs which are not mandatory, but are personally ones I would include in any project and demonstrate just how broad the ESLint ecosystem is. In fact, in the introduction of this blog I mentioned my distaste for Unicode U+2019 quotes - there is even [an ESLint plugin for that](https://github.com/seleb/eslint-plugin-no-smart-quotes)!

## Customising rules beyond recommended configurations

Depending on your taste, you might find that recommended configurations go too far, or not far enough. If that is the case, you can customise specific rules.

For example, for the above configurations I personally go a bit further and customise with the following (syntax is well documented on ESLint's or the respective plugin's websites):

```typescript
"spaced-comment": ["error", "always", { markers: ["/"] }],
"no-unneeded-ternary": "error",
"prefer-const": "error",
"max-params": ["error", 5],
"no-duplicate-imports": "error",
"no-self-compare": "error",
"no-template-curly-in-string": "error",
"no-useless-assignment": "error",
"no-useless-rename": "error",
"no-nested-ternary": "error",
"curly": "error",
"default-case-last": "error",
"default-param-last": "error",
"eqeqeq": "error",
"prefer-template": "error",
"react/jsx-curly-brace-presence": ["error", { props: "never", children: "never" }],
"react/jsx-fragments": ["error", "syntax"],
"react/jsx-no-useless-fragment": ["error", { allowExpressions: true }],
"react/jsx-newline": ["error", { prevent: true }],
"react/self-closing-comp": "error"
```

# tsconfig

This doesn't fall very nicely into the category of linting and formatting, but there are a few type-checking configuration options for the TypeScript compiler that are simply too powerful not to mention, both from a code cleanliness and reduced-risk-of-bugs perspective.

The easiest way to get your configuration into ship-shape is to go and add everything marked as "Recommended" in [TypeScript's documentation](https://www.typescriptlang.org/tsconfig/). There are a few, however, worth drawing extra attention to.

The absolute number one thing you should turn on is `strict: true`, which enables all of

- `alwaysStrict`
- `strictNullChecks`
- `strictBindCallApply`
- `strictBuiltinIteratorReturn`
- `strictFunctionTypes`
- `strictPropertyInitialization`
- `noImplicitAny`
- `noImplicitThis`
- `useUnknownInCatchVariables`

Special emphasis goes to `strictNullChecks`. If you don't like seeing `Uncaught TypeError: Cannot read properties of undefined`, this is an option for you.

A few more rules that are valuable for cleaner code are:

- `allowUnreachableCode` (as `false`)
- `noUnusedLocals`
- `noUnusedParameters`

## Knip

This might be the lesser known tool out of all that I am going through, however I can't overemphasise how much I love it. While ESLint is great at helping you identify and resolve problematic patterns within files, it is not so useful for catching issues that require looking across multiple files, or even dependencies. This is where Knip comes in.

The [Knip documentation](https://knip.dev/explanations/why-use-knip) has a very good overview of why to use this tool, but for me the two most important things are:

1. Identification of dead code (very importantly, this includes exported code which is never imported anywhere)
2. Identification of unused dependencies

Knip will run without any config file, however depending on the structure and the sort of dependencies you have in your project, it may come up with some false flags, or fail to identify some legitimate issues, in which case we need to tinker with it a little bit.

## How do we enforce all of this?

Having handy-dandy linting and formatting rules is all well and good, but if we are relying on simply trusting our team manually run some commands locally before committing, we're in for sore disappointment. Sometimes mistakes happen. Sometimes new starters join who don't know what scripts to run before committing. Despite our best efforts to set up all the tooling I've outlined above, we wouldn't reach the end of the day before unformatted unlinted code makes it into `master`.

Thankfully, there are a few strategies we can use to automate execution of our checks and tooling for developers to make their lives easier, and if it is necessitated, preventing their code reaching `master` if they've somehow avoided them.

My recommendation is a combination of all three of the following, which I will break down one at a time:

1. Recommended IDE extensions and settings that result in autoformatting/linting on save of files
2. Pre-commit hooks that run (and where possible autofix) issues prior to committing
3. Build pipeline checks to fail our build and prevent merging our pull request to master if the above two fail

### Recommended IDE extensions

This tip is unfortunately Visual Studio Code specific. While there is no guarantee everyone working on your project uses the same IDE, in 2025 VS Code continues to be ubiquitous in the industry so is worth mentioning.
Making a `.vscode` directory in our project enables us to add a couple of useful files that encourage consistency across developers.

#### .vscode/extensions.json

Here we can add a list of recommended extensions for which any developer opening your project will be prompted to install with a dialog that looks like this:

![VS Code Recommended Extension](/static/images/nitpicking/vscode_recommended_extension.webp)

Essential extensions to recommend, if you've followed this article up until now, are [EditorConfig for VS Code](https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig), [Prettier - Code formatter](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode) and [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint).

```json
{
	"recommendations": [
		"dbaeumer.vscode-eslint",
		"esbenp.prettier-vscode",
		"editorconfig.editorconfig"
	]
}
```

_If you want to add further extensions to `recommendations`, you can find the correct name to pass in under a value "Unique Identifier" found on the extension's marketplace page._

#### .vscode/settings.json

VS Code has two types of settings:

1. User Settings - This is your local VS Code configuration that will apply across any project that you open.
2. Workspace Settings - This applies just to the current project you have open, and is committed to source control.

We have no control over what our colleagues use for number 1, so number 2, workspace settings, is the important one.
There are many powerful configuration options we have at our disposal here which are worth researching, but focusing on the scope of formatting and linting, to enable automatic running of Prettier and ESLint on save, we can add the follow to our workspace `settings.json`:

```json
{
	"editor.formatOnSave": true,
	"editor.defaultFormatter": "esbenp.prettier-vscode",
	"editor.codeActionsOnSave": {
		"source.fixAll.eslint": "explicit"
	}
}
```

### Pre-commit hooks

If the developer managed to get save files without running our formatting and linting tools on them, perhaps because they weren't using VS Code or didn't install the recommended extensions, then the next safeguard in our arsenal is pre-commit hooks. These are simply scripts that automatically run locally on our machine before we commit.

In our case, we will use a very common combination of [husky](https://typicode.github.io/husky/) to implement our pre-commit hook and [lint-staged](https://github.com/lint-staged/lint-staged) to run linters on our staged files.

To get started, we will add the dependencies and initialise husky:

```shell
yarn add husky --dev
yarn add lint-staged --dev
yarn husky init
```

Now we want to define what `lint-staged` is actually going to run by adding a new property `lint-staged` to our `package.json`. _Ideally_, it would perform both linting and formatting, which would look something like this:

```json
"lint-staged": {
	"*.+(js|jsx|ts|tsx|json|css|md|mdx)": [
		"prettier --write",
		"eslint --fix"
	]
}
```

We then want to update `.husky/pre-commit` to actually run `lint-staged`. This is also a time where we could run `knip`:

```shell
yarn lint-staged
yarn knip
```

Above I said _"ideally"_, as there comes a time when we need to be pragmatic about what we run as a pre-commit hook. A good rule of thumb is that your checks should take no longer than about 10 seconds. Any longer is really going to start annoying developers working on your project. `prettier` is blazing fast so is always a no brainer to run, but `knip` and `eslint` may need to be culled on larger projects.

### Build pipeline

Even with recommending useful browser extensions and adding pre-commit hooks, you can be certain that some developer at some stage will manage to still bypass our linting. Maybe a junior on our team had `eslint` fail in a pre-commit hook script but the error message was confusing. They google it and find the solution is to just retry the commit with `--no-verify`. If that sneaks past code review, now we've got unlinted code into `master`.

This is where our final and 100% foolproof safeguard comes in - running all our checks in a build pipeline and having the result of that build be a static check which is required to pass before merging our code into master.

How you achieve this is going to be different based on what CI provider and git hosting platform you use, but my example will be for those using GitHub and GitHub Actions.

#### GitHub workflow

This one is simple. You just want to run all your static checks as build steps. Here is a sample workflow file you can use. I have saved this in `.github/workflows/static-checks.yml`:

```yaml
name: Code Validation

on:
    pull_request:
    workflow_dispatch:

jobs:
    build:
        name: Static Checks
        runs-on: ubuntu-latest
        steps:
            - uses: actions/checkout@v4
            - name: Install modules
              run: yarn
            - name: Lint
              run: yarn lint-nofix
            - name: Prettier
              run: yarn prettier-nofix
            - name: Knip
              run: yarn knip
```

#### GitHub repository settings

Next we want to apply some settings to our repository that ensure that only code that passes our `Static Checks` build can find its way into `master`.

1. Go to repository settings and create a new branch ruleset
   ![Create a branch ruleset](/static/images/nitpicking/github_ruleset_step_1.webp)
2. Name your ruleset (`main` or `master` should do the trick) and set the target branch to the default branch
   ![Set the target branch](/static/images/nitpicking/github_ruleset_step_2.webp)
3. Under "Branch rules" check "Require a pull request before merging" and "Require status checks to pass" ("Restrict deletions" and "Block force pushes" are selected by default)
   ![Configure branch rules](/static/images/nitpicking/github_ruleset_step_3.webp)
4. Expand "Show additional settings" under "Require status checks to pass" and select the "Static Checks" GitHub Action.
   ![Require static checks](/static/images/nitpicking/github_ruleset_step_4.webp)
5. Hit "Save Changes"

Now that we have made it so that no one can commit directly to `master` without a pull request and our new status check is required to pass to merge a pull request, the next time someone raises a pull request that doesn't pass our linting and formatting, they will see a UI that looks like this:

![Pull request with unsuccessful checks](/static/images/nitpicking/github_checks_not_successful_ui.webp)

## Why we should all be nitpickers

Granted, making the case in defense of spending our valuable time and energy worrying about the unimportant stylistic aspects of code is hard to do.

C. Northcote Parkinson, in 1957, spoke of a concept which has since become known as the [Law of Triviality](https://en.wikipedia.org/wiki/Law_of_triviality), which proposes that the amount of time we tend to spend discussing a problem is inversely proportional to the importance of the problem.

He

1. Less bugs
2. Less wasted time debating trivialities
3. Consistent code and user experience
4. Easier for new starters
